//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    customerGET(): Promise<CustomerListResponse> {
        let url_ = this.baseUrl + "/Customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerGET(_response);
        });
    }

    protected processCustomerGET(response: Response): Promise<CustomerListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerListResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerPOST(body: Customer | undefined): Promise<CustomerResponse> {
        let url_ = this.baseUrl + "/Customer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerPOST(_response);
        });
    }

    protected processCustomerPOST(response: Response): Promise<CustomerResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerResponse>(null as any);
    }

    /**
     * @return Success
     */
    customerGET2(id: string): Promise<CustomerResponse> {
        let url_ = this.baseUrl + "/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerGET2(_response);
        });
    }

    protected processCustomerGET2(response: Response): Promise<CustomerResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerPUT(id: string, body: Customer | undefined): Promise<CustomerResponse> {
        let url_ = this.baseUrl + "/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerPUT(_response);
        });
    }

    protected processCustomerPUT(response: Response): Promise<CustomerResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerResponse>(null as any);
    }

    /**
     * @return Success
     */
    customerDELETE(id: string): Promise<CustomerResponse> {
        let url_ = this.baseUrl + "/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerDELETE(_response);
        });
    }

    protected processCustomerDELETE(response: Response): Promise<CustomerResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerResponse>(null as any);
    }

    /**
     * @return Success
     */
    documentGET(): Promise<DocumentListResponse> {
        let url_ = this.baseUrl + "/Document";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentGET(_response);
        });
    }

    protected processDocumentGET(response: Response): Promise<DocumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentListResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    documentPOST(body: Document | undefined): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/Document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentPOST(_response);
        });
    }

    protected processDocumentPOST(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * @return Success
     */
    documentGET2(id: string): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentGET2(_response);
        });
    }

    protected processDocumentGET2(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    documentPUT(id: string, body: Document | undefined): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentPUT(_response);
        });
    }

    protected processDocumentPUT(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * @return Success
     */
    documentDELETE(id: string): Promise<DocumentResponse> {
        let url_ = this.baseUrl + "/Document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocumentDELETE(_response);
        });
    }

    protected processDocumentDELETE(response: Response): Promise<DocumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentResponse>(null as any);
    }

    /**
     * @return Success
     */
    orderGET(): Promise<OrderListResponse> {
        let url_ = this.baseUrl + "/Order";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderGET(_response);
        });
    }

    protected processOrderGET(response: Response): Promise<OrderListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderListResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderPOST(body: Order | undefined): Promise<OrderResponse> {
        let url_ = this.baseUrl + "/Order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderPOST(_response);
        });
    }

    protected processOrderPOST(response: Response): Promise<OrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderResponse>(null as any);
    }

    /**
     * @return Success
     */
    orderGET2(id: string): Promise<OrderResponse> {
        let url_ = this.baseUrl + "/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderGET2(_response);
        });
    }

    protected processOrderGET2(response: Response): Promise<OrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderPUT(id: string, body: Order | undefined): Promise<OrderResponse> {
        let url_ = this.baseUrl + "/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderPUT(_response);
        });
    }

    protected processOrderPUT(response: Response): Promise<OrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderResponse>(null as any);
    }

    /**
     * @return Success
     */
    orderDELETE(id: string): Promise<OrderResponse> {
        let url_ = this.baseUrl + "/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderDELETE(_response);
        });
    }

    protected processOrderDELETE(response: Response): Promise<OrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateRequest | undefined): Promise<UserSessionResponse> {
        let url_ = this.baseUrl + "/User/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: Response): Promise<UserSessionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSessionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSessionResponse>(null as any);
    }

    /**
     * @return Success
     */
    profile(): Promise<void> {
        let url_ = this.baseUrl + "/User/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthenticateRequest implements IAuthenticateRequest {
    username!: string;
    password!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticateRequest {
    username: string;
    password: string;
}

export class Customer implements ICustomer {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    street?: string | undefined;
    streetNumber?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    phone?: string | undefined;
    mobile?: string | undefined;
    whatsApp?: boolean | undefined;
    shoeSize?: number | undefined;
    disabled?: boolean | undefined;
    fibu?: number | undefined;
    comment?: string | undefined;
    salutation?: ECustomerSalutation;
    orders?: Order[] | undefined;
    documents?: Document[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.street = _data["street"];
            this.streetNumber = _data["streetNumber"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.whatsApp = _data["whatsApp"];
            this.shoeSize = _data["shoeSize"];
            this.disabled = _data["disabled"];
            this.fibu = _data["fibu"];
            this.comment = _data["comment"];
            this.salutation = _data["salutation"];
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["street"] = this.street;
        data["streetNumber"] = this.streetNumber;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["whatsApp"] = this.whatsApp;
        data["shoeSize"] = this.shoeSize;
        data["disabled"] = this.disabled;
        data["fibu"] = this.fibu;
        data["comment"] = this.comment;
        data["salutation"] = this.salutation;
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomer {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    street?: string | undefined;
    streetNumber?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    phone?: string | undefined;
    mobile?: string | undefined;
    whatsApp?: boolean | undefined;
    shoeSize?: number | undefined;
    disabled?: boolean | undefined;
    fibu?: number | undefined;
    comment?: string | undefined;
    salutation?: ECustomerSalutation;
    orders?: Order[] | undefined;
    documents?: Document[] | undefined;
}

export class CustomerListResponse implements ICustomerListResponse {
    data?: Customer[] | undefined;
    error?: ErrorDto;

    constructor(data?: ICustomerListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Customer.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerListResponse {
    data?: Customer[] | undefined;
    error?: ErrorDto;
}

export class CustomerResponse implements ICustomerResponse {
    data?: Customer;
    error?: ErrorDto;

    constructor(data?: ICustomerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Customer.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerResponse {
    data?: Customer;
    error?: ErrorDto;
}

export class Document implements IDocument {
    id?: string | undefined;
    googleId?: string | undefined;
    name?: string | undefined;
    creationDate?: Date;
    template?: boolean;
    incrementalId?: number | undefined;
    orderId?: string | undefined;
    customerId?: string | undefined;
    order?: Order;
    customer?: Customer;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.googleId = _data["googleId"];
            this.name = _data["name"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.template = _data["template"];
            this.incrementalId = _data["incrementalId"];
            this.orderId = _data["orderId"];
            this.customerId = _data["customerId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["googleId"] = this.googleId;
        data["name"] = this.name;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["template"] = this.template;
        data["incrementalId"] = this.incrementalId;
        data["orderId"] = this.orderId;
        data["customerId"] = this.customerId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocument {
    id?: string | undefined;
    googleId?: string | undefined;
    name?: string | undefined;
    creationDate?: Date;
    template?: boolean;
    incrementalId?: number | undefined;
    orderId?: string | undefined;
    customerId?: string | undefined;
    order?: Order;
    customer?: Customer;
}

export class DocumentListResponse implements IDocumentListResponse {
    data?: Document[] | undefined;
    error?: ErrorDto;

    constructor(data?: IDocumentListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Document.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocumentListResponse {
    data?: Document[] | undefined;
    error?: ErrorDto;
}

export class DocumentResponse implements IDocumentResponse {
    data?: Document;
    error?: ErrorDto;

    constructor(data?: IDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Document.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocumentResponse {
    data?: Document;
    error?: ErrorDto;
}

export enum ECustomerSalutation {
    Mr = "Mr",
    Mrs = "Mrs",
    Diverse = "Diverse",
    Company = "Company",
}

export enum EOrderShippingType {
    Send = "Send",
    Collect = "Collect",
    Visit = "Visit",
}

export enum EOrderTax {
    Nineteen = "Nineteen",
    Seven = "Seven",
}

export enum EOrderType {
    Einlagen = "Einlagen",
    Einlagenarbeiten = "Einlagenarbeiten",
    Abrolloptimierung = "Abrolloptimierung",
    Schuharbeiten = "Schuharbeiten",
    Massschuhleisten = "Massschuhleisten",
    Massschuhe = "Massschuhe",
    Schuhbestellung = "Schuhbestellung",
    Miscellaneous = "Miscellaneous",
}

export class ErrorDto implements IErrorDto {
    statuscode?: HttpStatusCode;
    message?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statuscode = _data["statuscode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statuscode"] = this.statuscode;
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    statuscode?: HttpStatusCode;
    message?: string | undefined;
}

export enum HttpStatusCode {
    Continue = "Continue",
    SwitchingProtocols = "SwitchingProtocols",
    Processing = "Processing",
    EarlyHints = "EarlyHints",
    OK = "OK",
    Created = "Created",
    Accepted = "Accepted",
    NonAuthoritativeInformation = "NonAuthoritativeInformation",
    NoContent = "NoContent",
    ResetContent = "ResetContent",
    PartialContent = "PartialContent",
    MultiStatus = "MultiStatus",
    AlreadyReported = "AlreadyReported",
    IMUsed = "IMUsed",
    MultipleChoices = "MultipleChoices",
    MovedPermanently = "MovedPermanently",
    Found = "Found",
    SeeOther = "SeeOther",
    NotModified = "NotModified",
    UseProxy = "UseProxy",
    Unused = "Unused",
    TemporaryRedirect = "TemporaryRedirect",
    PermanentRedirect = "PermanentRedirect",
    BadRequest = "BadRequest",
    Unauthorized = "Unauthorized",
    PaymentRequired = "PaymentRequired",
    Forbidden = "Forbidden",
    NotFound = "NotFound",
    MethodNotAllowed = "MethodNotAllowed",
    NotAcceptable = "NotAcceptable",
    ProxyAuthenticationRequired = "ProxyAuthenticationRequired",
    RequestTimeout = "RequestTimeout",
    Conflict = "Conflict",
    Gone = "Gone",
    LengthRequired = "LengthRequired",
    PreconditionFailed = "PreconditionFailed",
    RequestEntityTooLarge = "RequestEntityTooLarge",
    RequestUriTooLong = "RequestUriTooLong",
    UnsupportedMediaType = "UnsupportedMediaType",
    RequestedRangeNotSatisfiable = "RequestedRangeNotSatisfiable",
    ExpectationFailed = "ExpectationFailed",
    MisdirectedRequest = "MisdirectedRequest",
    UnprocessableEntity = "UnprocessableEntity",
    Locked = "Locked",
    FailedDependency = "FailedDependency",
    UpgradeRequired = "UpgradeRequired",
    PreconditionRequired = "PreconditionRequired",
    TooManyRequests = "TooManyRequests",
    RequestHeaderFieldsTooLarge = "RequestHeaderFieldsTooLarge",
    UnavailableForLegalReasons = "UnavailableForLegalReasons",
    InternalServerError = "InternalServerError",
    NotImplemented = "NotImplemented",
    BadGateway = "BadGateway",
    ServiceUnavailable = "ServiceUnavailable",
    GatewayTimeout = "GatewayTimeout",
    HttpVersionNotSupported = "HttpVersionNotSupported",
    VariantAlsoNegotiates = "VariantAlsoNegotiates",
    InsufficientStorage = "InsufficientStorage",
    LoopDetected = "LoopDetected",
    NotExtended = "NotExtended",
    NetworkAuthenticationRequired = "NetworkAuthenticationRequired",
}

export class Order implements IOrder {
    id?: string | undefined;
    creationDate?: Date;
    pending?: boolean;
    shippingType?: EOrderShippingType;
    comment?: string | undefined;
    price?: number | undefined;
    taxes?: EOrderTax;
    dueDate?: Date | undefined;
    type?: EOrderType;
    brand?: string | undefined;
    article?: string | undefined;
    color?: string | undefined;
    dealer?: string | undefined;
    size?: number | undefined;
    name?: string | undefined;
    customerId?: string | undefined;
    documents?: Document[] | undefined;
    customer?: Customer;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.pending = _data["pending"];
            this.shippingType = _data["shippingType"];
            this.comment = _data["comment"];
            this.price = _data["price"];
            this.taxes = _data["taxes"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.brand = _data["brand"];
            this.article = _data["article"];
            this.color = _data["color"];
            this.dealer = _data["dealer"];
            this.size = _data["size"];
            this.name = _data["name"];
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(Document.fromJS(item));
            }
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["pending"] = this.pending;
        data["shippingType"] = this.shippingType;
        data["comment"] = this.comment;
        data["price"] = this.price;
        data["taxes"] = this.taxes;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["brand"] = this.brand;
        data["article"] = this.article;
        data["color"] = this.color;
        data["dealer"] = this.dealer;
        data["size"] = this.size;
        data["name"] = this.name;
        data["customerId"] = this.customerId;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrder {
    id?: string | undefined;
    creationDate?: Date;
    pending?: boolean;
    shippingType?: EOrderShippingType;
    comment?: string | undefined;
    price?: number | undefined;
    taxes?: EOrderTax;
    dueDate?: Date | undefined;
    type?: EOrderType;
    brand?: string | undefined;
    article?: string | undefined;
    color?: string | undefined;
    dealer?: string | undefined;
    size?: number | undefined;
    name?: string | undefined;
    customerId?: string | undefined;
    documents?: Document[] | undefined;
    customer?: Customer;
}

export class OrderListResponse implements IOrderListResponse {
    data?: Order[] | undefined;
    error?: ErrorDto;

    constructor(data?: IOrderListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Order.fromJS(item));
            }
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderListResponse {
    data?: Order[] | undefined;
    error?: ErrorDto;
}

export class OrderResponse implements IOrderResponse {
    data?: Order;
    error?: ErrorDto;

    constructor(data?: IOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? Order.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderResponse {
    data?: Order;
    error?: ErrorDto;
}

export class UserSession implements IUserSession {
    token?: string | undefined;
    id?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUserSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.id = _data["id"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserSession {
        data = typeof data === 'object' ? data : {};
        let result = new UserSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["id"] = this.id;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserSession {
    token?: string | undefined;
    id?: string | undefined;
    email?: string | undefined;
}

export class UserSessionResponse implements IUserSessionResponse {
    data?: UserSession;
    error?: ErrorDto;

    constructor(data?: IUserSessionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserSession.fromJS(_data["data"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserSessionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserSessionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserSessionResponse {
    data?: UserSession;
    error?: ErrorDto;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}